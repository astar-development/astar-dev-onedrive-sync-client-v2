using AStar.Dev.Source.Generators.ServiceRegistrationGeneration;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace AStar.Dev.Source.Generators.Tests.Unit.ServiceRegistrationGeneration;

public class ServiceRegistrationGeneratorShould()
{
    private const string AttributeSource = @"using System; 

namespace AStar.Dev.Source.Generators.Attributes 
{     
    public enum ServiceLifetime 
    { 
        Singleton, 
        Scoped, 
        Transient 
    }
    
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class AutoRegisterServiceAttribute : Attribute 
    {  
        public AutoRegisterServiceAttribute(ServiceLifetime lifetime = ServiceLifetime.Scoped) { Lifetime = lifetime; }  
        public ServiceLifetime Lifetime { get; }  
        public Type? As { get; set; }
        public bool AsSelf { get; set; } = false;
    } 
}
";

    private static CSharpCompilation CreateCompilation(string input)
    {
        PortableExecutableReference diReference = MetadataReference.CreateFromFile(typeof(Microsoft.Extensions.DependencyInjection.IServiceCollection).Assembly.Location);
        return CSharpCompilation.Create("TestAssembly",
            [
                CSharpSyntaxTree.ParseText(AttributeSource),
                CSharpSyntaxTree.ParseText(input)
            ],
            [
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(Attribute).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Runtime.AssemblyTargetedPatchBandAttribute).Assembly.Location),
                diReference
            ],
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
    }

    [Fact]
    public void RegisterClassWithSingleInterface_DefaultScoped()
    {
        const string input = @"using AStar.Dev.Source.Generators.Attributes;

namespace TestNamespace
{ 
    public interface IFoo { } 
    
    [AutoRegisterService] 
    public class Foo : IFoo { } 
}
";
        CSharpCompilation compilation = CreateCompilation(input);
        var generator = new ServiceRegistrationGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver)driver.RunGenerators(compilation, TestContext.Current.CancellationToken);
        GeneratorDriverRunResult result = driver.GetRunResult();
        GeneratedSourceResult generated = result.Results.SelectMany(r => r.GeneratedSources).FirstOrDefault(x => x.HintName.Contains("ServiceCollectionExtensions"));
        generated.Equals(default(GeneratedSourceResult)).ShouldBeFalse();
        var text = generated.SourceText.ToString();

        text.ShouldBe(@"// <auto-generated/>
using Microsoft.Extensions.DependencyInjection;

namespace TestNamespace;

public static class GeneratedServiceCollectionExtensions
{
    public static IServiceCollection AddAnnotatedServices(this IServiceCollection services)
    {
        services.AddScoped<global::TestNamespace.IFoo, global::TestNamespace.Foo>();
        return services;
    }
}
");
    }

    [Fact]
    public void RegisterClassWithSingleInterface_SingletonLifetime()
    {
        const string input = @"using AStar.Dev.Source.Generators.Attributes;

namespace TestNamespace 
{ 
    public interface IFoo { } 
    
    [AutoRegisterService(ServiceLifetime.Singleton)] 
    public class Foo : IFoo { } 
}";
        CSharpCompilation compilation = CreateCompilation(input);
        var generator = new ServiceRegistrationGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver)driver.RunGenerators(compilation, TestContext.Current.CancellationToken);
        GeneratorDriverRunResult result = driver.GetRunResult();
        GeneratedSourceResult generated = result.Results.SelectMany(r => r.GeneratedSources).FirstOrDefault(x => x.HintName.Contains("ServiceCollectionExtensions"));
        generated.Equals(default(GeneratedSourceResult)).ShouldBeFalse();
        var text = generated.SourceText.ToString();

        text.ShouldBe(@"// <auto-generated/>
using Microsoft.Extensions.DependencyInjection;

namespace TestNamespace;

public static class GeneratedServiceCollectionExtensions
{
    public static IServiceCollection AddAnnotatedServices(this IServiceCollection services)
    {
        services.AddSingleton<global::TestNamespace.IFoo, global::TestNamespace.Foo>();
        return services;
    }
}
");
    }

    [Fact]
    public void RegisterClassWithSingleInterface_AsSelfTrue()
    {
        const string input = @"using AStar.Dev.Source.Generators.Attributes;

namespace TestNamespace
{
    public interface IFoo { } 
    
    [AutoRegisterService(AsSelf = true)] 
    public class Foo : IFoo { } 
}";
        CSharpCompilation compilation = CreateCompilation(input);
        var generator = new ServiceRegistrationGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver)driver.RunGenerators(compilation, TestContext.Current.CancellationToken);
        GeneratorDriverRunResult result = driver.GetRunResult();
        GeneratedSourceResult generated = result.Results.SelectMany(r => r.GeneratedSources).FirstOrDefault(x => x.HintName.Contains("ServiceCollectionExtensions"));
        generated.Equals(default(GeneratedSourceResult)).ShouldBeFalse();
        var text = generated.SourceText.ToString();

        text.ShouldBe(@"// <auto-generated/>
using Microsoft.Extensions.DependencyInjection;

namespace TestNamespace;

public static class GeneratedServiceCollectionExtensions
{
    public static IServiceCollection AddAnnotatedServices(this IServiceCollection services)
    {
        services.AddScoped<global::TestNamespace.IFoo, global::TestNamespace.Foo>();
        services.AddScoped<global::TestNamespace.Foo>();
        return services;
    }
}
");
    }

    [Fact]
    public void RegisterClassWithTwoInterfaces_AsOverride()
    {
        const string input = @"using AStar.Dev.Source.Generators.Attributes;

namespace TestNamespace 
{ 
    public interface IFoo { } 
    
    public interface IBar { } 
    
    [AutoRegisterService(As = typeof(IBar))] 
    public class Foo : IFoo, IBar { } 
}";
        CSharpCompilation compilation = CreateCompilation(input);
        var generator = new ServiceRegistrationGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver)driver.RunGenerators(compilation, TestContext.Current.CancellationToken);
        GeneratorDriverRunResult result = driver.GetRunResult();
        GeneratedSourceResult generated = result.Results.SelectMany(r => r.GeneratedSources).FirstOrDefault(x => x.HintName.Contains("ServiceCollectionExtensions"));
        generated.Equals(default(GeneratedSourceResult)).ShouldBeFalse();
        var text = generated.SourceText.ToString();

        text.ShouldBe(@"// <auto-generated/>
using Microsoft.Extensions.DependencyInjection;

namespace TestNamespace;

public static class GeneratedServiceCollectionExtensions
{
    public static IServiceCollection AddAnnotatedServices(this IServiceCollection services)
    {
        services.AddScoped<global::TestNamespace.IBar, global::TestNamespace.Foo>();
        return services;
    }
}
");
    }

    [Fact]
    public void RegisterClassWithNoInterface_AsSelfTrue()
    {
        const string input = @"using AStar.Dev.Source.Generators.Attributes;

namespace TestNamespace 
{
    [AutoRegisterService(AsSelf = true)]
    public class Foo { } 
}
";
        CSharpCompilation compilation = CreateCompilation(input);
        var generator = new ServiceRegistrationGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver)driver.RunGenerators(compilation, TestContext.Current.CancellationToken);
        GeneratorDriverRunResult result = driver.GetRunResult();
        GeneratedSourceResult generated = result.Results.SelectMany(r => r.GeneratedSources).FirstOrDefault(x => x.HintName.Contains("ServiceCollectionExtensions"));
        generated.Equals(default(GeneratedSourceResult)).ShouldBeFalse();
        var text = generated.SourceText.ToString();

        text.ShouldBe(@"// <auto-generated/>
using Microsoft.Extensions.DependencyInjection;

namespace TestNamespace;

public static class GeneratedServiceCollectionExtensions
{
    public static IServiceCollection AddAnnotatedServices(this IServiceCollection services)
    {
        services.AddScoped<global::TestNamespace.Foo>();
        return services;
    }
}
");
    }

    [Fact]
    public void DoesNotRegisterAbstractOrNonPublicOrGenericClasses()
    {
        const string input = @"using AStar.Dev.Source.Generators.Attributes;

namespace TestNamespace 
{ 
    public interface IFoo { } 
    
    [AutoRegisterService]
    public abstract class AbstractFoo : IFoo { } 
    
    [AutoRegisterService] internal class InternalFoo : IFoo 
    { } 
    
    [AutoRegisterService] 
    public class GenericFoo<T> : IFoo { } 
}
";
        CSharpCompilation compilation = CreateCompilation(input);
        var generator = new ServiceRegistrationGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver)driver.RunGenerators(compilation, TestContext.Current.CancellationToken);
        GeneratorDriverRunResult result = driver.GetRunResult();
        GeneratedSourceResult generated = result.Results.SelectMany(r => r.GeneratedSources).FirstOrDefault(x => x.HintName.Contains("ServiceCollectionExtensions"));
        generated.Equals(default(GeneratedSourceResult)).ShouldBeTrue();
    }

    [Fact]
    public void DoesNotRegisterClassWithoutServiceAttribute()
    {
        const string input = @"namespace TestNamespace
{
    public interface IFoo { } 

    public class Foo : IFoo { } 
}";
        CSharpCompilation compilation = CreateCompilation(input);
        var generator = new ServiceRegistrationGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver)driver.RunGenerators(compilation, TestContext.Current.CancellationToken);
        GeneratorDriverRunResult result = driver.GetRunResult();
        GeneratedSourceResult generated = result.Results.SelectMany(r => r.GeneratedSources).FirstOrDefault(x => x.HintName.Contains("ServiceCollectionExtensions"));

        if(!generated.Equals(default(GeneratedSourceResult)))
        {
            var text = generated.SourceText.ToString();

            text.ShouldNotContain("Foo");
        }
    }

    [Fact]
    public void DoesNotRegisterClassWithMultipleInterfacesAndNoAsSpecified()
    {
        const string input = @"using AStar.Dev.Source.Generators.Attributes;
namespace TestNamespace
{
    public interface IFoo { }
    public interface IBar { }

    [AutoRegisterService]
    public class Foo : IFoo, IBar
    { }
}
";
        CSharpCompilation compilation = CreateCompilation(input);
        var generator = new ServiceRegistrationGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver)driver.RunGenerators(compilation, TestContext.Current.CancellationToken);
        GeneratorDriverRunResult result = driver.GetRunResult();
        GeneratedSourceResult generated = result.Results.SelectMany(r => r.GeneratedSources).FirstOrDefault(x => x.HintName.Contains("ServiceCollectionExtensions"));

        if(!generated.Equals(default(GeneratedSourceResult)))
        {
            var text = generated.SourceText.ToString();

            text.ShouldNotContain("Foo");
        }
    }

    [Fact]
    public void DoesNotGenerateExtensionWhenNoServicesAnnotated()
    {
        const string input = @"namespace TestNamespace
{
    public interface IFoo { }

    public class Foo : IFoo { }
}";
        CSharpCompilation compilation = CreateCompilation(input);
        var generator = new ServiceRegistrationGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver)driver.RunGenerators(compilation, TestContext.Current.CancellationToken);

        GeneratorDriverRunResult result = driver.GetRunResult();
        GeneratedSourceResult generated = result.Results.SelectMany(r => r.GeneratedSources).FirstOrDefault(x => x.HintName.Contains("ServiceCollectionExtensions"));

        generated.Equals(default(GeneratedSourceResult)).ShouldBeTrue();
    }
}

